{"version":3,"file":"lib.modern.js","sources":["../src/utils/audio.ts","../src/utils/createWorkletModuleLoader.ts","../src/utils/rawAudioProcessor.ts","../src/utils/compatibility.ts","../src/utils/input.ts","../src/utils/audioConcatProcessor.ts","../src/utils/output.ts","../src/utils/events.ts","../src/utils/connection.ts","../src/index.ts"],"sourcesContent":["export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const URLCache = new Map<string, string>();\n\nexport function createWorkletModuleLoader(name: string, sourceCode: string) {\n  return async (worklet: AudioWorklet) => {\n    const url = URLCache.get(name);\n    if (url) {\n      return worklet.addModule(url);\n    }\n\n    const blob = new Blob([sourceCode], { type: \"application/javascript\" });\n    const blobURL = URL.createObjectURL(blob);\n    try {\n      await worklet.addModule(blobURL);\n      URLCache.set(name, blobURL);\n      return;\n    } catch {\n      URL.revokeObjectURL(blobURL);\n    }\n\n    try {\n      // Attempting to start a conversation in Safari inside an iframe will\n      // throw a CORS error because the blob:// protocol is considered\n      // cross-origin. In such cases, fall back to using a base64 data URL:\n      const base64 = btoa(sourceCode);\n      const moduleURL = `data:application/javascript;base64,${base64}`;\n      await worklet.addModule(moduleURL);\n      URLCache.set(name, moduleURL);\n    } catch (error) {\n      throw new Error(\n        `Failed to load the ${name} worklet module. Make sure the browser supports AudioWorklets.`\n      );\n    }\n  };\n}\n","/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadRawAudioProcessor = createWorkletModuleLoader(\n  \"raw-audio-processor\",\n  // language=JavaScript\n  `\nconst BIAS = 0x84;\nconst CLIP = 32635;\nconst encodeTable = [\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n];\n\nfunction encodeSample(sample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let muLawSample;\n  sign = (sample >> 8) & 0x80;\n  if (sign !== 0) sample = -sample;\n  sample = sample + BIAS;\n  if (sample > CLIP) sample = CLIP;\n  exponent = encodeTable[(sample>>7) & 0xFF];\n  mantissa = (sample >> (exponent+3)) & 0x0F;\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\n  \n  return muLawSample;\n}\n\nclass RawAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n              \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.isMuted = false;\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = data.sampleRate / 4;\n          this.format = data.format;\n\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n          break;\n        case \"setMuted\":\n          this.isMuted = data.isMuted;\n          break;\n      }\n    };\n  }\n  process(inputs) {\n    if (!this.buffer) {\n      return true;\n    }\n    \n    const input = inputs[0]; // Get the first input node\n    if (input.length > 0) {\n      let channelData = input[0]; // Get the first channel's data\n\n      // Resample the audio if necessary\n      if (this.resampler) {\n        channelData = this.resampler.full(channelData);\n      }\n\n      // Add channel data to the buffer\n      this.buffer.push(...channelData);\n      // Get max volume \n      let sum = 0.0;\n      for (let i = 0; i < channelData.length; i++) {\n        sum += channelData[i] * channelData[i];\n      }\n      const maxVolume = Math.sqrt(sum / channelData.length);\n      // Check if buffer size has reached or exceeded the threshold\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = this.isMuted \n          ? new Float32Array(this.buffer.length)\n          : new Float32Array(this.buffer);\n\n        let encodedArray = this.format === \"ulaw\"\n          ? new Uint8Array(float32Array.length)\n          : new Int16Array(float32Array.length);\n\n        // Iterate through the Float32Array and convert each sample to PCM16\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to the range [-1, 1]\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n          // Scale the sample to the range [-32768, 32767]\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\n          if (this.format === \"ulaw\") {\n            value = encodeSample(Math.round(value));\n          }\n\n          encodedArray[i] = value;\n        }\n\n        // Send the buffered data to the main script\n        this.port.postMessage([encodedArray, maxVolume]);\n\n        // Clear the buffer after sending\n        this.buffer = [];\n      }\n    }\n    return true; // Continue processing\n  }\n}\nregisterProcessor(\"raw-audio-processor\", RawAudioProcessor);\n`\n);\n","export function isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport function isAndroidDevice() {\n  return /android/i.test(navigator.userAgent);\n}\n","import { loadRawAudioProcessor } from \"./rawAudioProcessor\";\nimport { FormatConfig } from \"./connection\";\nimport { isIosDevice } from \"./compatibility\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        echoCancellation: { ideal: true },\n        noiseSuppression: { ideal: true },\n      };\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await loadRawAudioProcessor(context.audioWorklet);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: options,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      await context.resume();\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n\n  public setMuted(isMuted: boolean) {\n    this.worklet.port.postMessage({ type: \"setMuted\", isMuted });\n  }\n}\n","/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadAudioConcatProcessor = createWorkletModuleLoader(\n  \"audio-concat-processor\",\n  // language=JavaScript\n  `\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nexport function decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.format = data.format;\n          break;\n        case \"buffer\":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === \"ulaw\"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case \"interrupt\":\n          this.wasInterrupted = true;\n          break;\n        case \"clearInterrupted\":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === \"ulaw\") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: \"process\", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n`\n);\n","import { loadAudioConcatProcessor } from \"./audioConcatProcessor\";\nimport { FormatConfig } from \"./connection\";\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n  }: FormatConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await loadAudioConcatProcessor(context.audioWorklet);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      await context.resume();\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n","import { Language } from \"./connection\";\n\nexport type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AgentAudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n    user_input_audio_format?: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    ping_ms?: number;\n  };\n};\nexport type ClientToolCallEvent = {\n  type: \"client_tool_call\";\n  client_tool_call: {\n    tool_name: string;\n    tool_call_id: string;\n    parameters: any;\n    expects_response: boolean;\n  };\n};\n\n// TODO correction missing\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent;\n\nexport type PongEvent = {\n  type: \"pong\";\n  event_id: number;\n};\nexport type UserAudioEvent = {\n  user_audio_chunk: string;\n};\nexport type UserFeedbackEvent = {\n  type: \"feedback\";\n  score: \"like\" | \"dislike\";\n  event_id: number;\n};\nexport type ClientToolResultEvent = {\n  type: \"client_tool_result\";\n  tool_call_id: string;\n  result: any;\n  is_error: boolean;\n};\nexport type InitiationClientDataEvent = {\n  type: \"conversation_initiation_client_data\";\n  conversation_config_override?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      first_message?: string;\n      language?: Language;\n    };\n    tts?: {\n      voice_id?: string;\n    };\n  };\n  custom_llm_extra_body?: any;\n  dynamic_variables?: Record<string, string | number | boolean>;\n};\nexport type ContextualUpdateEvent = {\n  type: \"contextual_update\";\n  text: string;\n};\nexport type UserMessageEvent = {\n  type: \"user_message\";\n  text: string;\n};\nexport type UserActivityEvent = {\n  type: \"user_activity\";\n};\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent\n  | ContextualUpdateEvent\n  | UserMessageEvent\n  | UserActivityEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import {\n  InitiationClientDataEvent,\n  ConfigEvent,\n  isValidSocketEvent,\n  OutgoingSocketEvent,\n  IncomingSocketEvent,\n} from \"./events\";\n\nconst MAIN_PROTOCOL = \"convai\";\n\nexport type Language =\n  | \"en\"\n  | \"ja\"\n  | \"zh\"\n  | \"de\"\n  | \"hi\"\n  | \"fr\"\n  | \"ko\"\n  | \"pt\"\n  | \"pt-br\"\n  | \"it\"\n  | \"es\"\n  | \"id\"\n  | \"nl\"\n  | \"tr\"\n  | \"pl\"\n  | \"sv\"\n  | \"bg\"\n  | \"ro\"\n  | \"ar\"\n  | \"cs\"\n  | \"el\"\n  | \"fi\"\n  | \"ms\"\n  | \"da\"\n  | \"ta\"\n  | \"uk\"\n  | \"ru\"\n  | \"hu\"\n  | \"hr\"\n  | \"sk\"\n  | \"no\"\n  | \"vi\";\nexport type SessionConfig = {\n  origin?: string;\n  authorization?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n  };\n  customLlmExtraBody?: any;\n  dynamicVariables?: Record<string, string | number | boolean>;\n  useWakeLock?: boolean;\n  connectionDelay?: {\n    default: number;\n    android?: number;\n    ios?: number;\n  };\n} & (\n  | { signedUrl: string; agentId?: undefined }\n  | { agentId: string; signedUrl?: undefined }\n);\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n};\nexport type DisconnectionDetails =\n  | {\n      reason: \"error\";\n      message: string;\n      context: Event;\n    }\n  | {\n      reason: \"agent\";\n      context: CloseEvent;\n    }\n  | {\n      reason: \"user\";\n    };\nexport type OnDisconnectCallback = (details: DisconnectionDetails) => void;\nexport type OnMessageCallback = (event: IncomingSocketEvent) => void;\n\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class Connection {\n  public static async create(config: SessionConfig): Promise<Connection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + WSS_API_PATHNAME + config.agentId;\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent: InitiationClientDataEvent = {\n              type: \"conversation_initiation_client_data\",\n            };\n\n            if (config.overrides) {\n              overridesEvent.conversation_config_override = {\n                agent: {\n                  prompt: config.overrides.agent?.prompt,\n                  first_message: config.overrides.agent?.firstMessage,\n                  language: config.overrides.agent?.language,\n                },\n                tts: {\n                  voice_id: config.overrides.tts?.voiceId,\n                },\n              };\n            }\n\n            if (config.customLlmExtraBody) {\n              overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n            }\n\n            if (config.dynamicVariables) {\n              overridesEvent.dynamic_variables = config.dynamicVariables;\n            }\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n        socket!.addEventListener(\"error\", event => {\n          // In case the error event is followed by a close event, we want the\n          // latter to be the one that rejects the promise as it contains more\n          // useful information.\n          setTimeout(() => reject(event), 0);\n        });\n        socket!.addEventListener(\"close\", reject);\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new Connection(socket, conversation_id, inputFormat, outputFormat);\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  private queue: IncomingSocketEvent[] = [];\n  private disconnectionDetails: DisconnectionDetails | null = null;\n  private onDisconnectCallback: OnDisconnectCallback | null = null;\n  private onMessageCallback: OnMessageCallback | null = null;\n\n  private constructor(\n    public readonly socket: WebSocket,\n    public readonly conversationId: string,\n    public readonly inputFormat: FormatConfig,\n    public readonly outputFormat: FormatConfig\n  ) {\n    this.socket.addEventListener(\"error\", event => {\n      // In case the error event is followed by a close event, we want the\n      // latter to be the one that disconnects the session as it contains more\n      // useful information.\n      setTimeout(\n        () =>\n          this.disconnect({\n            reason: \"error\",\n            message: \"The connection was closed due to a socket error.\",\n            context: event,\n          }),\n        0\n      );\n    });\n    this.socket.addEventListener(\"close\", event => {\n      this.disconnect(\n        event.code === 1000\n          ? {\n              reason: \"agent\",\n              context: event,\n            }\n          : {\n              reason: \"error\",\n              message:\n                event.reason || \"The connection was closed by the server.\",\n              context: event,\n            }\n      );\n    });\n    this.socket.addEventListener(\"message\", event => {\n      try {\n        const parsedEvent = JSON.parse(event.data);\n        if (!isValidSocketEvent(parsedEvent)) {\n          return;\n        }\n\n        if (this.onMessageCallback) {\n          this.onMessageCallback(parsedEvent);\n        } else {\n          this.queue.push(parsedEvent);\n        }\n      } catch (_) {}\n    });\n  }\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n\n  public onMessage(callback: OnMessageCallback) {\n    this.onMessageCallback = callback;\n    this.queue.forEach(callback);\n    this.queue = [];\n  }\n\n  public onDisconnect(callback: OnDisconnectCallback) {\n    this.onDisconnectCallback = callback;\n    if (this.disconnectionDetails) {\n      callback(this.disconnectionDetails);\n    }\n  }\n\n  private disconnect(details: DisconnectionDetails) {\n    if (!this.disconnectionDetails) {\n      this.disconnectionDetails = details;\n      this.onDisconnectCallback?.(details);\n    }\n  }\n}\n\nfunction parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = parseInt(sampleRatePart);\n  if (isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input, InputConfig } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport {\n  Connection,\n  DisconnectionDetails,\n  OnDisconnectCallback,\n  SessionConfig,\n} from \"./utils/connection\";\nimport { ClientToolCallEvent, IncomingSocketEvent } from \"./utils/events\";\nimport { isAndroidDevice, isIosDevice } from \"./utils/compatibility\";\n\nexport type { InputConfig } from \"./utils/input\";\nexport type { IncomingSocketEvent } from \"./utils/events\";\nexport type {\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n} from \"./utils/connection\";\nexport type Role = \"user\" | \"ai\";\nexport type Mode = \"speaking\" | \"listening\";\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig;\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onDisconnect: OnDisconnectCallback;\n  onError: (message: string, context?: any) => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  onAudio: (base64Audio: string) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onCanSendFeedbackChange: (prop: { canSendFeedback: boolean }) => void;\n  onUnhandledClientToolCall?: (\n    params: ClientToolCallEvent[\"client_tool_call\"]\n  ) => void;\n};\n\nconst defaultClientTools = { clientTools: {} };\nconst defaultCallbacks: Callbacks = {\n  onConnect: () => {},\n  onDebug: () => {},\n  onDisconnect: () => {},\n  onError: () => {},\n  onMessage: () => {},\n  onAudio: () => {},\n  onModeChange: () => {},\n  onStatusChange: () => {},\n  onCanSendFeedbackChange: () => {},\n};\n\nconst HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport class Conversation {\n  public static async startSession(\n    options: SessionConfig &\n      Partial<Callbacks> &\n      Partial<ClientToolsConfig> &\n      Partial<InputConfig>\n  ): Promise<Conversation> {\n    const fullOptions: Options = {\n      ...defaultClientTools,\n      ...defaultCallbacks,\n      ...options,\n    };\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n    fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n\n    let input: Input | null = null;\n    let connection: Connection | null = null;\n    let output: Output | null = null;\n    let preliminaryInputStream: MediaStream | null = null;\n\n    let wakeLock: WakeLockSentinel | null = null;\n    if (options.useWakeLock ?? true) {\n      try {\n        wakeLock = await navigator.wakeLock.request(\"screen\");\n      } catch (e) {\n        // Wake Lock is not required for the conversation to work\n      }\n    }\n\n    try {\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      const delayConfig = options.connectionDelay ?? {\n        default: 0,\n        // Give the Android AudioManager enough time to switch to the correct audio mode\n        android: 3_000,\n      };\n      let delay = delayConfig.default;\n      if (isAndroidDevice()) {\n        delay = delayConfig.android ?? delay;\n      } else if (isIosDevice()) {\n        delay = delayConfig.ios ?? delay;\n      }\n\n      if (delay > 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n\n      connection = await Connection.create(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n        }),\n        Output.create(connection.outputFormat),\n      ]);\n\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      preliminaryInputStream = null;\n\n      return new Conversation(fullOptions, connection, input, output, wakeLock);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      try {\n        await wakeLock?.release();\n        wakeLock = null;\n      } catch (e) {}\n      throw error;\n    }\n  }\n\n  private lastInterruptTimestamp: number = 0;\n  private mode: Mode = \"listening\";\n  private status: Status = \"connecting\";\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n  private volume: number = 1;\n  private currentEventId: number = 1;\n  private lastFeedbackEventId: number = 1;\n  private canSendFeedback: boolean = false;\n\n  private constructor(\n    private readonly options: Options,\n    private readonly connection: Connection,\n    public readonly input: Input,\n    public readonly output: Output,\n    public wakeLock: WakeLockSentinel | null\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n\n    this.connection.onDisconnect(this.endSessionWithDetails);\n    this.connection.onMessage(this.onMessage);\n\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession = () => this.endSessionWithDetails({ reason: \"user\" });\n\n  private endSessionWithDetails = async (details: DisconnectionDetails) => {\n    if (this.status !== \"connected\" && this.status !== \"connecting\") return;\n    this.updateStatus(\"disconnecting\");\n\n    try {\n      await this.wakeLock?.release();\n      this.wakeLock = null;\n    } catch (e) {}\n\n    this.connection.close();\n    await this.input.close();\n    await this.output.close();\n\n    this.updateStatus(\"disconnected\");\n    this.options.onDisconnect(details);\n  };\n\n  private updateMode = (mode: Mode) => {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  };\n\n  private updateStatus = (status: Status) => {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  };\n\n  private updateCanSendFeedback = () => {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      this.options.onCanSendFeedbackChange({ canSendFeedback });\n    }\n  };\n\n  private onMessage = async (parsedEvent: IncomingSocketEvent) => {\n    switch (parsedEvent.type) {\n      case \"interruption\": {\n        if (parsedEvent.interruption_event) {\n          this.lastInterruptTimestamp = parsedEvent.interruption_event.event_id;\n        }\n        this.fadeOutAudio();\n        return;\n      }\n\n      case \"agent_response\": {\n        this.options.onMessage({\n          source: \"ai\",\n          message: parsedEvent.agent_response_event.agent_response,\n        });\n        return;\n      }\n\n      case \"user_transcript\": {\n        this.options.onMessage({\n          source: \"user\",\n          message: parsedEvent.user_transcription_event.user_transcript,\n        });\n        return;\n      }\n\n      case \"internal_tentative_agent_response\": {\n        this.options.onDebug({\n          type: \"tentative_agent_response\",\n          response:\n            parsedEvent.tentative_agent_response_internal_event\n              .tentative_agent_response,\n        });\n        return;\n      }\n\n      case \"client_tool_call\": {\n        if (\n          this.options.clientTools.hasOwnProperty(\n            parsedEvent.client_tool_call.tool_name\n          )\n        ) {\n          try {\n            const result =\n              (await this.options.clientTools[\n                parsedEvent.client_tool_call.tool_name\n              ](parsedEvent.client_tool_call.parameters)) ??\n              \"Client tool execution successful.\"; // default client-tool call response\n\n            // The API expects result to be a string, so we need to convert it if it's not already a string\n            const formattedResult =\n              typeof result === \"object\"\n                ? JSON.stringify(result)\n                : String(result);\n\n            this.connection.sendMessage({\n              type: \"client_tool_result\",\n              tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n              result: formattedResult,\n              is_error: false,\n            });\n          } catch (e) {\n            this.onError(\n              \"Client tool execution failed with following error: \" +\n                (e as Error)?.message,\n              {\n                clientToolName: parsedEvent.client_tool_call.tool_name,\n              }\n            );\n            this.connection.sendMessage({\n              type: \"client_tool_result\",\n              tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n              result: \"Client tool execution failed: \" + (e as Error)?.message,\n              is_error: true,\n            });\n          }\n        } else {\n          if (this.options.onUnhandledClientToolCall) {\n            this.options.onUnhandledClientToolCall(\n              parsedEvent.client_tool_call\n            );\n\n            return;\n          }\n\n          this.onError(\n            `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n            }\n          );\n          this.connection.sendMessage({\n            type: \"client_tool_result\",\n            tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n            result: `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            is_error: true,\n          });\n        }\n\n        return;\n      }\n\n      case \"audio\": {\n        if (this.lastInterruptTimestamp <= parsedEvent.audio_event.event_id) {\n          this.options.onAudio(parsedEvent.audio_event.audio_base_64);\n          this.addAudioBase64Chunk(parsedEvent.audio_event.audio_base_64);\n          this.currentEventId = parsedEvent.audio_event.event_id;\n          this.updateCanSendFeedback();\n          this.updateMode(\"speaking\");\n        }\n        return;\n      }\n\n      case \"ping\": {\n        this.connection.sendMessage({\n          type: \"pong\",\n          event_id: parsedEvent.ping_event.event_id,\n        });\n        // parsedEvent.ping_event.ping_ms can be used on client side, for example\n        // to warn if ping is too high that experience might be degraded.\n        return;\n      }\n\n      // unhandled events are expected to be internal events\n      default: {\n        this.options.onDebug(parsedEvent);\n        return;\n      }\n    }\n  };\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n    const maxVolume = event.data[1];\n\n    // check if the sound was loud enough, so we don't send unnecessary chunks\n    // then forward audio to websocket\n    //if (maxVolume > 0.001) {\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n        //sample_rate: this.inputAudioContext?.inputSampleRate || this.inputSampleRate,\n      });\n    }\n    //}\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private onError = (message: string, context?: any) => {\n    console.error(message, context);\n    this.options.onError(message, context);\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public getId = () => this.connection.conversationId;\n\n  public isOpen = () => this.status === \"connected\";\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public setMicMuted = (isMuted: boolean) => {\n    this.input.setMuted(isMuted);\n  };\n\n  public getInputByteFrequencyData = () => {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  };\n\n  public getOutputByteFrequencyData = () => {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  };\n\n  public getInputVolume = () => {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  };\n\n  public getOutputVolume = () => {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  };\n\n  public sendFeedback = (like: boolean) => {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  };\n\n  public sendContextualUpdate = (text: string) => {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text,\n    });\n  };\n\n  public sendUserMessage = (text: string) => {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text,\n    });\n  };\n\n  public sendUserActivity = () => {\n    this.connection.sendMessage({\n      type: \"user_activity\",\n    });\n  };\n}\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin: string = HTTPS_API_ORIGIN\n) {\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify({\n      feedback: like ? \"like\" : \"dislike\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n"],"names":["arrayBufferToBase64","b","buffer","Uint8Array","window","btoa","String","fromCharCode","base64ToArrayBuffer","base64","binaryString","atob","len","length","bytes","i","charCodeAt","URLCache","Map","createWorkletModuleLoader","name","sourceCode","async","url","get","worklet","addModule","blob","Blob","type","blobURL","URL","createObjectURL","set","_unused","revokeObjectURL","moduleURL","error","Error","loadRawAudioProcessor","isIosDevice","includes","navigator","platform","userAgent","document","Input","create","sampleRate","format","preferHeadphonesForIosDevices","context","inputStream","options","ideal","echoCancellation","noiseSuppression","idealDevice","mediaDevices","enumerateDevices","find","d","kind","keyword","label","toLowerCase","deviceId","supportsSampleRateConstraint","getSupportedConstraints","AudioContext","analyser","createAnalyser","audioWorklet","getUserMedia","audio","source","createMediaStreamSource","AudioWorkletNode","port","postMessage","connect","resume","_inputStream","_context","getTracks","forEach","track","stop","close","constructor","this","setMuted","isMuted","loadAudioConcatProcessor","Output","gain","createGain","destination","isValidSocketEvent","event","Connection","config","socket","_config$origin","origin","signedUrl","agentId","protocols","authorization","push","WebSocket","conversationConfig","Promise","resolve","reject","addEventListener","_socket","overridesEvent","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","overrides","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","customLlmExtraBody","custom_llm_extra_body","dynamicVariables","dynamic_variables","send","JSON","stringify","once","setTimeout","message","parse","data","conversation_initiation_metadata_event","console","warn","conversation_id","agent_output_audio_format","user_input_audio_format","inputFormat","parseFormat","outputFormat","_socket2","conversationId","queue","disconnectionDetails","onDisconnectCallback","onMessageCallback","disconnect","reason","code","parsedEvent","_","sendMessage","onMessage","callback","onDisconnect","details","_this$onDisconnectCal","call","formatPart","sampleRatePart","split","parseInt","isNaN","defaultClientTools","clientTools","defaultCallbacks","onConnect","onDebug","onError","onAudio","onModeChange","onStatusChange","onCanSendFeedbackChange","Conversation","startSession","_options$useWakeLock","fullOptions","_extends","status","canSendFeedback","input","connection","output","preliminaryInputStream","wakeLock","useWakeLock","request","e","_options$connectionDe","_preliminaryInputStre","delayConfig","connectionDelay","default","android","delay","_delayConfig$android","test","_delayConfig$ios","ios","all","_preliminaryInputStre2","_connection","_input","_output","_wakeLock","release","_this","lastInterruptTimestamp","mode","inputFrequencyData","outputFrequencyData","volume","currentEventId","lastFeedbackEventId","endSession","endSessionWithDetails","updateStatus","_this$wakeLock","updateMode","updateCanSendFeedback","interruption_event","event_id","fadeOutAudio","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","hasOwnProperty","client_tool_call","tool_name","_await$_this$options$","result","parameters","formattedResult","tool_call_id","is_error","clientToolName","onUnhandledClientToolCall","audio_event","audio_base_64","addAudioBase64Chunk","ping_event","onInputWorkletMessage","user_audio_chunk","onOutputWorkletMessage","finished","chunk","value","exponentialRampToValueAtTime","currentTime","calculateVolume","frequencyData","getId","isOpen","setVolume","setMicMuted","getInputByteFrequencyData","frequencyBinCount","getByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","sendFeedback","like","score","sendContextualUpdate","text","sendUserMessage","sendUserActivity","onmessage","postOverallFeedback","fetch","method","body","feedback","headers"],"mappings":"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"}